\documentclass[10pt,a4paper]{article}
\usepackage[cm]{fullpage}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[russian]{babel}
\usepackage{listings}
\author{Кевролетин В.В. 236гр.}
\title{$\lambda$-исчисление}
\begin{document}

\maketitle

\subsection*{Задание31}
Привести пример функции $f:N\rightarrow N$, которая обладает свойством
$f(1)+f(2)\not =f(2)+f(1)$. Объяснить причину такого поведения.
\subsubsection*{Условие}
\subsubsection*{Решение}
\begin{lstlisting}
(define count 0)

(define (f x)
  (set! count (* (+ count x) x))
  count)
\end{lstlisting}

Результат, возвращаемый описанной выше функции f(x) зависит от
глобальной переменной
count, значение которой меняется в теле этой же функции. Поэтому
результат функции зависит не только от переданного ей аргумента, но и
от
последовательности предыдущих вызовов f(x).
$f(1)+f(2)\not =f(2)+f(1)$ несмотря на коммутативность сложения,
потому что в первом случае сначала вычисляется f(1) а потом f(2), а во
втором случае наоборот.

\subsection*{Задание32}
\subsubsection*{Условие}
In the make-withdraw procedure, the local variable balance is created
as a parameter of make-withdraw. We could also create the local state
variable explicitly, using let, as follows:
\begin{lstlisting}
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
\end{lstlisting}
Show that the two versions of make-withdraw create objects with the
same behavior. How do the environment structures differ for the two
versions?
\subsubsection*{Решение}

\lstset{ %
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
frame=single
}
\begin{lstlisting}

       +----------------------------------------------------+
global |                                                    |
env    | make-withdraw----+                                 |
       |                  |                                 |
       |                  |                                 |
       +------------------|---------------------------------+
                          |       ^
                          |      /|\
                          |       |
                         \|/      |
                          '       |
                 parameters: initial-amount
                 body:(let ((balance initial-amount))
                        (lambda (amount)
                          (if (>= balance amount)
                             (begin (set! balance (- balance amount))
                                    balance)
                             "Insufficient funds"))))

\end{lstlisting}

После выполнения (define W1 (make-withdraw 100)) будет создан объект
w1. Ниже на схеме изображено состояние окружения после сознания w1. На
схеме видно, что полученный объект не отличается от созданного в 1 версии.

\begin{lstlisting}

       +----------------------------------------------------+
global | make-withdraw ...                                  |   /
env    |                                                    |  <----------------+
       | w1---+                                             |   \               |
       |      |                                             |                   |
       +------|---------------------------------------------+                   |
              |                                                  +---------+    |
              |    +----------------------------------------+    |         |    |
              |    |                                       \|/   |        \|/   |
             \|/   |                                        '    |         '    |
              '    |                                      +---------+ +---------------+
 parameters: initial-amount                               | balance:| | initial-amount|
 body:                                                    |   100   | |      100      |
                                                          +---------+ +---------------+
       (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))

\end{lstlisting}

\lstset{ %
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
frame=none
}


\subsection*{Задание33}
\subsubsection*{Условие}
make-cycle
\subsubsection*{Решение}

Было:
\begin{lstlisting}

      +---+---+       +---+---+       +---+---+
z-->  |   |   +---->  |   |   +---->  |   |   +---->  null
      +-+-+---+       +-+-+---+       +-+-+---+
        |               |               |
       \|/             \|/             \|/
        '               '               '
        a               b               c

\end{lstlisting}

Станет:
\begin{lstlisting}

        +------------------------------------------+
        |                                          |
       \|/                                         |
        '                                          |
      +---+---+       +---+---+       +---+---+    |
z-->  |   |   +---->  |   |   +---->  |   |   +----+
      +-+-+---+       +-+-+---+       +-+-+---+
        |               |               |
       \|/             \|/             \|/
        '               '               '
        a               b               c

\end{lstlisting}

Вызов (last-pair z) приведёт к зацикливанию выполнения программы,
т.к. условие (null? x) не выполняется не для одного элемента списка.

\subsection*{Задание34}
\subsubsection*{Условие}
mystery
\begin{lstlisting}
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
\end{lstlisting}
\subsubsection*{Решение}
Процедура делает то же самое что и reverce

\begin{lstlisting}

       +---+---+       +---+---+       +---+---+       +---+---+
v-->   |   |   +---->  |   |   +---->  |   |   +---->  |   |   +---->  null
       +-+-+---+       +-+-+---+       +-+-+---+       +-+-+---+
         |               |               |               |
        \|/             \|/             \|/             \|/
         '               '               '               '
         a               b               c               d


       +---+---+       +---+---+       +---+---+       +---+---+
v-->   |   |   +---->  |   |   +---->  |   |   +---->  |   |   +----> null
       +-+-+---+       +-+-+---+       +-+-+---+       +-+-+---+
         |               |               |               |
        \|/             \|/             \|/             \|/
         '               '               '               '
         d               c               b               a

\end{lstlisting}

\subsection*{Задание35}
\subsubsection*{Условие}
count-pairs
\subsubsection*{Решение}
3
\begin{lstlisting}

 +---+---+       +---+---+       +---+---+
 |   |   +---->  |   |   +---->  |   |   +---->  null
 +-+-+---+       +-+-+---+       +-+-+---+
   |               |               |
  \|/             \|/             \|/
   '               '               '
   a               b               c

\end{lstlisting}
4
\begin{lstlisting}
                   +---------------+
                   |              \|/
                   |               '
 +---+---+       +-+-+---+       +---+---+
 |   |   +---->  |   |   +---->  |   |   +---->  null
 +-+-+---+       +-+-+---+       +-+-+---+
   |                               |
  \|/                             \|/
   '                               '
   a                               c

\end{lstlisting}
7
\begin{lstlisting}

                   +---------------+
                   |              \|/
                   |               '
 +---+---+       +-+-+---+       +---+---+
 |   |   +---->  |   |   +---->  |   |   +---->  null
 +-+-+---+       +---+---+       +-+-+---+
   |               ^               |
   |              /|\             \|/
   +---------------+               '
                                   c

\end{lstlisting}
Никогда не завершится
\begin{lstlisting}
   +----------------------------------------+
  \|/                                       |
   '                                        |
 +---+---+       +---+---+       +---+---+  |
 |   |   +---->  |   |   +---->  |   |   +--+
 +-+-+---+       +-+-+---+       +-+-+---+
   |               |               |
  \|/             \|/             \|/
   '               '               '
   a               b               c

\end{lstlisting}



\subsection*{Задание36}
\subsubsection*{Условие}
A correct version of the count-pairs.
\subsubsection*{Решение}
В моей версии пары, которые мы уже посчитали помещаются в список
counted. Перед тем как учесть очередную пару проверяется есть ли она
в списке counted. Если есть то не считаем её. Если нет то учитываем её
и помещаем её в список counted.
\begin{lstlisting}
(define (in-list l x)
  (cond ((null? l) 0)
        ((eq? (car l) x) 1)
        (else (in-list (cdr l) x))))

(define (push l x)
  (set-cdr! l (pair x '())))

(define counted '())

(define (count-pairs x)
  (cond
   ((not (pair? x)) 0)
   ((in-list counted x) 0)
   (else
    (push counted x)
    (+ (count-pairs (car x))
            (count-pairs (cdr x))
            1))))
\end{lstlisting}

\subsection*{Задание37}
\subsubsection*{Условие}
print-queue
\subsubsection*{Решение}
\begin{lstlisting}

       +---+---+
q--->  |   |   +-----------------------------------------+
       +-+-+---+                                         |
         |                                              \|/rear-ptr
        \|/front-ptr                                     '
         '
       +---+---+       +---+---+       +---+---+       +---+---+
       |   |   +---->  |   |   +---->  |   |   +---->  |   |   +---->  null
       +-+-+---+       +-+-+---+       +-+-+---+       +-+-+---+
         |               |               |               |
        \|/             \|/             \|/             \|/
         '               '               '               '
         a               b               c               d

\end{lstlisting}
Видно, что до последнего элемента можно дойти 2мя путями, поэтому
интерпретатор печатает его дважды. \\
Чтобы распечатать все элементы очереди без повторения достаточно
просто просто распечатать список, на который указывает front-ptr, и не
печатать хвост, на который указывает rear-ptr:
\begin{lstlisting}
(define (print-queue q) (pront-ptr q))
\end{lstlisting}

\subsection*{Задание38}
\subsubsection*{Условие}
queue как процедура с локальными состояниями
\subsubsection*{Решение}
\begin{lstlisting}
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))

    (define (empty-queue?) (null? front-ptr))
    (define (front-queue)
      (if (empty-queue?)
          (error "FRONT called with an empty queue")
      (car front-ptr)))
    (define (insert-queue!)
      (lambda (item)
        (let ((new-pair (cons item '())))
          (cond ((empty-queue?)
                 (set! front-ptr new-pair)
                 (set! rear-ptr new-pair))
                (else
                 (set-cdr! rear-ptr new-pair)
                 (set! rear-ptr new-pair))))))
    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "DELETE! called with an empty queue"))
            (else
             (set! front-ptr (cdr front-ptr))
             queue)))

    (define (dispatch m)
      (cond
       ((eq? m 'front-ptr) front-ptr)
       ((eq? m 'rear-ptr) rear-ptr)
       ((eq? m 'empty-queue?) (empty-queue?))
       ((eq? m 'front-queue) (front-queue))
       ((eq? m 'insert-queue!) (insert-queue!))
       ((eq? m 'delete-queue!) (delete-queue!))
       (else (error "Undefined operation -- QUEUE" m))))
    dispatch))

(define (front-ptr q) (q 'rear-ptr))
(define (rear-ptr q) (q 'front-ptr))
(define (empty-queue? q) (q 'empty-queue?))
(define (front-queue q) (q 'front-queue))
(define (insert-queue! q v) ((q 'insert-queue!) v))
(define (delete-queue! q) (q 'delete-queue!))
\end{lstlisting}

\subsection*{Задание39}
\subsubsection*{Условие}
\subsubsection*{Решение}
\begin{lstlisting}

 |front-ptr                                                      rear-ptr|
 |                                                                       |
 |          null                                                         |
 |           ^                                                           |
 |          /|\     +--------+      +--------+      +--------+           |
 |           |      |        |      |        |      |        |           |
 |     +---+-+-+    |  +---+-+-+    |  +---+-+-+    |  +---+-+-+         |
 +-->  |   |   | <--+  |   |   | <--+  |   |   | <--+  |   |   |  <------+
       +-+-+---+       +-+-+---+       +-+-+---+       +-+-+---+
         |               |               |               |
        \|/             \|/             \|/             \|/
         '               '               '               '
       +---+---+       +---+---+       +---+---+       +---+---+
       |   |   +---->  |   |   +---->  |   |   +---->  |   |   +----> null
       +-+-+---+       +-+-+---+       +-+-+---+       +-+-+---+
         |               |               |               |
        \|/             \|/             \|/             \|/
         '               '               '               '
         a               b               c               d

\end{lstlisting}

\subsection*{Задание40}
\subsubsection*{Условие}
\subsubsection*{Решение}
\begin{lstlisting}
\end{lstlisting}

\end{document}
